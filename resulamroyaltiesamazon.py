# -*- coding: utf-8 -*-
"""ResulamRoyaltiesAmazon.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ViaDS-PSkY3qR5C35kJARdoQIJirVfEq
"""





"""# Script"""

#  pip install dash openpyxl pandas plotly

# -*- coding: utf-8 -*-
"""ResulamRoyaltiesAmazon.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ViaDS-PSkY3qR5C35kJARdoQIJirVfEq

# Import Data
"""


# --------------------
# Imports (all at top, deduplicated)
# --------------------
import pandas as pd
import re
from datetime import datetime
import plotly.express as px
import plotly.graph_objects as go
import dash
from dash import html, dcc, Input, Output
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature
from geopy.geocoders import Nominatim

current_year = datetime.now().year
last_year = current_year - 1


main_dir = r"G:\My Drive\Mbú'ŋwɑ̀'nì\RoyaltiesResulam"

resulam_books_path = main_dir + r"\Resulam_books_database_Amazon_base_de_donnee_livres.csv"
resulam_books_path_xls = main_dir + r"\Resulam_books_database_Amazon_base_de_donnee_livres.xlsx"
royalties_resulam_path = main_dir + fr"\KDP_OrdersResulamBookSales{last_year}RoyaltiesReports.xlsx"
royalties_resulam_history_path = main_dir + f"\KDP_OrdersResulamBookSales2015_{last_year}RoyaltiesReportsHistory.xlsx"



# Use UTF-8 encoding for reading files
books = pd.read_csv(resulam_books_path, encoding="utf-8")

sell_this_year = pd.read_excel(royalties_resulam_path, sheet_name="Combined Sales")
sell_history = pd.read_excel(royalties_resulam_history_path, sheet_name="Combined Sales")
sell_history_ebook = pd.read_excel(royalties_resulam_history_path, sheet_name="eBook Royalty")
sell_history_paper = pd.read_excel(royalties_resulam_history_path, sheet_name="Paperback Royalty")
sell_history_hardcover = pd.read_excel(royalties_resulam_history_path, sheet_name="Hardcover Royalty")

ASIN_Ebook = sell_history_ebook["ASIN"].unique()
ISBN_Paper = sell_history_paper["ISBN"].unique()
ISBN_HardCovers = sell_history_hardcover["ISBN"].unique()



author_names_dict = {
    "Rodrigue": "Shck",
    "Shck Shck": "Shck",
    "Rodrigue Tchamna": "Shck Tchamna",
    "Zachée Denis BITJAA  KODY": "Pr Zachée Denis BITJAA KODY",
    "Zachee Bitjaa Kody": "Pr Zachée Denis BITJAA KODY",
    'Resulam Resulam': "Resulam",
    "Jean rene Djobia": "Tanyi Djobia René",
    "Jean René Djobia": "Tanyi Djobia René",
    "Tanyi Djobia Rene": "Tanyi Djobia René",

    'Tchamna': "Shck Tchamna",
    "Mə̂fo Gòmlù’ Gòmlù’ Motoum": "Mə̂fo Gòmlù’ Motoum",
    "Pascaline Motoum": "Mə̂fo Gòmlù’ Motoum",
    'SHCK Tchamna': "Shck Tchamna",
    "Claude Lionel Mvondo" :" Claude Lionel Mvondo Edzoa",
    "IMELE TSAFACK": "Imele Tsafack",
    "Tsafack Imele": "Imele Tsafack",
    "Joseph Oyange Wajuanga":"Joseph Oyange",
    "Josephine Ndonke":"Joséphine Ndonke",
     "Iyo Ngobo Ekwalla":"Ngobo Ekwala",
    "Oliver Germain Tafouemewe":"Olivier Tafouemewe",


}

# author_names_dict = {
#     "Shck Shck Tchamna":"Shck Tchamna",
#     "Shck Shck Tchamna":"Shck Tchamna",
#     "Shck Ca᷅mnà'":"Shck Tchamna",
#     "Shck Cǎmnà'":"Shck Tchamna",

#     "Claude Lionel Mvondo Edzoa": "Claude Lionel Mvondo",
#     "IMELE TSAFACK": "Imele Tsafack",
#     "Tsafack Imele": "Imele Tsafack",
#     "Jean rene Djobia":"Jean René Djobia",
#     "Tanyi Djobia Rene":"Jean René Djobia",
#     "Joseph Oyange Wajuanga":"Joseph Oyange",
#     "Josephine Ndonke":"Joséphine Ndonke",
#     "Pascaline Motoum":"Mə̂fo Gòmlù’ Motoum",
#     "Oliver Germain Tafouemewe":"Olivier Tafouemewe",
#     "Zachée Denis BITJAA KODY":"Pr Zachée Denis BITJAA KODY",
#     "Zachee Bitjaa Kody":"Pr Zachée Denis BITJAA KODY",
#     "Iyo Ngobo Ekwalla":"Ngobo Ekwala",


# }

#Rename Authors, Names Normalization
sell_this_year['Author Name'] = sell_this_year['Author Name'].str.strip()
sell_this_year['Author Name'] = sell_this_year['Author Name'].apply(lambda x: author_names_dict.get(x, x))


books['authors'] = books['authors'].str.strip()
books['authors'] = books['authors'].apply(lambda x: author_names_dict.get(x, x))

sell_history['Author Name'].str.strip()
sell_history['Author Name'] = sell_history['Author Name'].apply(lambda x: author_names_dict.get(x, x))

# Function to strip and replace multiple spaces
def strip_and_replace_spaces(cell):
    if isinstance(cell, str):
        cell = cell.strip()  # Strip leading and trailing spaces
        cell = re.sub(r'\s+', ' ', cell)  # Replace multiple spaces with a single space
    return cell

# Apply the function to each element in the DataFrame
sell_history = sell_history.applymap(strip_and_replace_spaces)

# Apply the function to each element in the DataFrame
# sell_this_year = sell_this_year.apply(lambda x: x.replace("Rodrigue","Shck"))
# sell_this_year = sell_this_year.apply(lambda x: x.replace("Shck Shck","Shck"))
# sell_this_year = sell_this_year.apply(lambda x: x.replace("Ca᷅mnà'","Tchamna"))

books = books.rename(columns={"title":"Title"})
# books = books.apply(lambda x: x.replace("Rodrigue","Shck"))
# books = books.apply(lambda x: x.replace("Shck Shck","Shck"))
# books = books.apply(lambda x: x.replace("Ca᷅mnà'","Tchamna"))


rename_dict = {"Conversation de base": "Conversations de base",
               "Guide de conversation trilingue français-anglais-yemba": "Guide de conversation trilingue français-anglais-yemba: French-Yemba-English Phrasebook"}

for key, value in rename_dict.items():
    sell_this_year["Title"] = sell_this_year["Title"].str.replace(key, value)
    sell_history["Title"] = sell_history["Title"].str.replace(key, value)

for key, value in rename_dict.items():
    books["Title"] = books["Title"].str.replace(key, value)

books["Title"] = books["Title"].apply(lambda x: x.split("–")[0].strip())

sell_this_year["Title"] = sell_this_year["Title"].apply(lambda x: x.strip())
sell_history["Title"] = sell_history["Title"].apply(lambda x: x.strip())



# sell_history_paper["ISBN"]

# books
# sell_this_year

# sell_this_year["Title"].unique()







print(f"Number of Paper Book: {len(ISBN_Paper)}")
print(f"Number of Hard cover Book: {len(ISBN_HardCovers)}")
print(f"Number of Ebooks: {len(ASIN_Ebook)}")



books.head(2)

sell_this_year.head(2)

sell_history.head(2)

sell_this_year["Title"].loc[0]

def lang_nufi(x):
    if "nùfī" in x.lower() or "nufi" in x.lower() or "fe'efe'e" in x.lower() or "Nzhìèkǔ’ mɑ̀nkō ngʉ́ngà'" in x:
        return "Nufi"
    elif "medumba" in x.lower():
        return "Medumba"
    elif "yemba" in x.lower():
        return "Yemba"
    elif "yoruba" in x.lower():
        return "Yoruba"
    elif "duala" in x.lower():
        return "Duala"
    elif "yoruba" in x.lower():
        return "Yoruba"
    elif "fongbe" in x.lower():
        return "Fongbe"
    elif "Ŋgə̂mbà" in x:
        return "Ngemba"
    else:
        return x

#     Yoruba  Attic: Le Grenier du Yoruba: Òkè Àjà Yorùbá



# len(books['authors'])
# # len( books['Title'])


# Extracting the columns as lists
titles = books['Title'].tolist()
book_nick_names = books['book_nick_name'].tolist()
book_authors = books['authors'].tolist()
book_language_names = books['language_name'].tolist()


# Creating the dictionary using zip
books_nicknames_dict = dict(zip(titles, book_nick_names))
books_authors_dict = dict(zip(titles, book_authors))
books_languages_dict = dict(zip(titles, book_language_names))

books_languages_dict.update({})

# books_nicknames_dict


update_ = {
    "La fourmi affamée : Ŋgə̂mbà – Français: Tə́ttá pfʉ́ njjikhwu’ú":"Shck Tchamna, Gabriel Deeh Segallo",
"Contes bamilekés racontés en medumba et traduits en français: medumba (bangante) fairy tales":"Shck Tchamna, Leopold Tchoumi",
"Conte Africain -Fongbe: « Travaille aujourd’hui et mange demain paresse aujourd’hui et vole demain »":"Shck Tchamna, Richard Hounsossou",
"Guide de conversation trilingue français-anglais-douala: French-Duala-English Phrasebook": "Iyo Ngobo Ekwalla, Shck Tchamna",
"Guide de conversation trilingue français-anglais-medumba: French-Medumba-English Phrasebook" : "Tanyi Djobia Rene, Leopold Tchoumi, Shck Tchamna",
"Basaa  Attic: Le Grenier du Basaa: Ndùgí ì Ɓàsàá": "Shck Tchamna, Ngo Bibouth",
"Le Grenier du Hausa : Hausa Attic": " Resulam, Shck Tchamna"
}


books_authors_dict.update(update_)

# sell_this_year_2

# sell_this_year_2.apply(replace_author, axis=1)

# sell_history["Authors"].unique()

# sell_this_year["book_nick_name"] = sell_this_year["Title"].apply(lambda x: books_nicknames_dict[x]
# #                                                        if x in books_nicknames_dict else x )

# sell_this_year["Authors"] = sell_this_year["Title"].apply(lambda x: books_authors_dict[x]
#                                                        if x in books_authors_dict else None )

# sell_this_year["Languages"] = sell_this_year["Title"].apply(lambda x: books_languages_dict[x]
#                                                        if x in books_languages_dict else None )
sell_this_year["book_nick_name"] = sell_this_year["Title"].replace(books_nicknames_dict)
sell_this_year["Authors"] = sell_this_year["Title"].replace(books_authors_dict)
sell_this_year["Language"] = sell_this_year["Title"].replace(books_languages_dict)

# sell_history["book_nick_name"] = sell_history["Title"].apply(lambda x: books_nicknames_dict[x]
#                                                        if x in books_nicknames_dict else x )

# sell_history["Authors"] = sell_history["Title"].apply(lambda x: books_authors_dict[x]
#                                                        if x in books_authors_dict else None )

sell_history["book_nick_name"] = sell_history["Title"].replace(books_nicknames_dict)
sell_history["Authors"] = sell_history["Title"].replace(books_authors_dict)
sell_history["Language"] = sell_history["Title"].replace(books_languages_dict)

sell_history["Title"]
# mask = sell_this_year["Authors"].apply(lambda x: True if x is None else False)
# sell_this_year[mask]

col_interest = ["Royalty Date", "Title","ASIN/ISBN", "Language", "book_nick_name","Authors", "Units Sold", "Units Refunded", "Net Units Sold",
                "Marketplace","Royalty Type","Transaction Type","Royalty","Currency",
                ]

sell_this_year_2 = sell_this_year[col_interest].copy()
# sell_this_year_2.sort_values(by="Royalty Date",ascending=False)

sell_history_2 = sell_history[col_interest].copy()
# sell_this_year_2.sort_values(by="Royalty Date",ascending=False)

# grouped_df_history_count["Authors_Exploded"].unique()


def replace_author(x):
    if 'Guide de conversation trilingue français-anglais-yemba' in x['Title']:
        return 'Giresse Jiokeng Feutsa, Oliver Germain Tafouemewe, Shck Tchamna'
    elif "Contes bamilekés racontés en medumba et traduits en français (Black and White)" in x["Title"]:
        return "Leopold Tchoumi"

    elif "Yoruba - French - English Phrasebook: Guide de conversation Yoruba – Français - Anglais" in x["Title"]:
        return "Resulam, Shck Tchamna"

    elif "Le Grenier du Nguemba: Ntâŋ Ŋgə̂mbà : Ngemba Attic" in x["Title"]:
        return "Deeh Segallo, Resulam, Shck Tchamna"

    elif "La fourmi affamée: Nzhìèkǔ’ mɑ̀nkō ngʉ́ngà'" in x["Title"]:
        return "Resulam, Shck Tchamna"


    elif x['Authors'] is None:
        return "Resulam, Shck Tchamna"
    elif "nùfī" in x['Title'].lower() or "nufi" in x['Title'].lower() or "fe'efe'e" in x['Title'].lower():
        return "Resulam, Shck Tchamna"
    elif "nùfī" in x['Title'].lower():
        return "Resulam, Shck Tchamna"
    else:
        return x['Authors']

# def replace_book_nick_name(x):
#     if "Nùfī Attic - Le Grenier du Nùfī - KAM 1: Ntǎ' Nùfī" in x['Title']:
#         return 'NtaNufi_Ebook'
#     elif "Nùfī Attic - Le Grenier du Nùfī - KAM 2: Ntǎ' Nùfī" in x['Title']:
#         return 'NtaNufi_Ebook'
#     elif "Nùfī Attic - Le Grenier du Nùfī - KAM 3: Ntǎ' Nùfī" in x['Title']:
#         return 'NtaNufi_Ebook'
#     elif "Nùfī Attic - Le Grenier du Nùfī - KAM 4: Ntǎ' Nùfī" in x['Title']:
#         return 'NtaNufi_Ebook'
#     elif "Nùfī Attic - Le Grenier du Nùfī - KAM 5: Ntǎ' Nùfī" in x['Title']:
#         return 'NtaNufi_Ebook'
#     elif "Nùfī Attic - Le Grenier du Nùfī - KAM 6: Ntǎ' Nùfī" in x['Title']:
#         return 'NtaNufi_Ebook'
#     elif "Nùfī Attic - Le Grenier du Nùfī - KAM 7: Ntǎ' Nùfī" in x['Title']:
#         return 'NtaNufi_Ebook'
#     elif "Nùfī Attic - Le Grenier du Nùfī - KAM 8: Ntǎ' Nùfī" in x['Title']:
#         return 'NtaNufi_Ebook'

#     elif "Ntǎ' Nùfī - Nùfī Attic - Le Grenier du Nùfī (Version sans audio)" in x['Title']:
#         return 'NtaNufi_Ebook'
#     elif "Guide de conversation trilingue Français-anglais-fe'efe'e.: French-Fè'éfě'è-English Phrasebook" in x['Title']:
#         return 'nufi_phrasebook'
#     elif "La grammaire des langues bamilekes : cas du nufi" in x['Title']:
#         return 'nufi_grammaire'



#     else:
#         return x['Title']


def replace_book_nick_name(title):
    # A dictionary mapping unique parts of titles to their new nicknames
    title_mappings = {f"Nùfī Attic - Le Grenier du Nùfī - KAM {i}:": "nufi_attic_interactive" for i in range(1, 9)}
    title_mappings.update({
        "Ntǎ' Nùfī - Nùfī Attic - Le Grenier du Nùfī (Version sans audio)": "nufi_attic_ebook",
        "Conte Africain -Fongbe: « Travaille aujourd’hui et mange demain, paresse aujourd’hui et vole demain » – January 15, 2019" : "fongbe_conte_travaille_paresse",
        "Conte Africain -Fongbe: « Travaille aujourd’hui et mange demain, paresse aujourd’hui et vole demain »." : "fongbe_conte_travaille_paresse",

        "Guide de conversation trilingue Français-anglais-fe'efe'e.: French-Fè'éfě'è-English Phrasebook": "nufi_phrasebook",
        "La grammaire des langues bamilekes : cas du nufi": "nufi_grammaire",
        "La fourmi affamée : Nufi-Français: Nzhìèkǔ’ mɑ̀nkō ngʉ́ngà'": "nufi_fourmi_affamee",
        "Contes africains, contes bamilekés racontés en nufi et traduits en francais (Full Color): African's fairy tales": "nufi_contes_bamilekes",
        "Conversations de base en langue fe'efe'e: Basic Conversation in Fe'efe'e Language":"nufi_conv.base",
        "Conte Bamiléké-Nufi « Travaille aujourd’hui et mange demain, paresse aujourd’hui et vole demain ».: Version Nufi-Francais":"nufi_travail_paresse",
        "Contes africains, contes bamilékés racontés en nufi et traduits en français (Black and White): African's fairy tales":"nufi_contes_bamileke_black_white",
        "Contes bamilekés racontés en medumba et traduits en français (Black and White): medumba (Bangangte) Fairy tales":"medumba_contes_bamilekes_black_white",
        "Contes bamilekés racontés en medumba et traduits en français: medumba (bangante) fairy tales":"medumba_contes_bamileke_couleur",
        "Expressions idiomatiques en langue fè'éfě'è (nùfī): Yū' mfèn pí yū' nkɑ̀ndàk mɑ̀ ghə̀ə̄ fè'éfě'è (nùfī)":"nufi_expression_idiom.",
        "Grammaire des langues bamilékés : Cas du nufi (fè'éfě'è): Sìēmbʉ́ɑ́ fè'éfě'è": "nufi_grammaire",
        "Guide de conversation (phrasebook) en langue fe'efe'e (nufi) - part I: Trilingual Phrasebook : French-English-Nufi": "nufi_phrasebook",
        "Guide de conversation trilingue français-anglais-douala: French-Duala-English Phrasebook": "duala_phrasebook",
        "Guide de conversation trilingue français-anglais-medumba: French-Medumba-English Phrasebook":"medumba_phrasebook",
        "Guide de conversation trilingue français-anglais-yemba: French-Yemba-English Phrasebook":"yemba_phrasebook",
        "La fourmi affamée: Nzhìèkǔ’ mɑ̀nkō ngʉ́ngà'":"nufi_fourmi_affamee",
        "Le Grenier du Nguemba: Ntâŋ Ŋgə̂mbà : Ngemba Attic":"ngemba_grenier",
        "Syllabaire et dictionnaire visuel en langue nufi (fe’efe’e): Nkǔnjâ'wū pí mbíághəə":"nufi_syllabaire",
        "Yoruba - French - English Phrasebook: Guide de conversation Yoruba – Français - Anglais":"yoruba_phrasebook",
        "Contes africains, contes bamilekés racontés en nufi et traduits en francais: African's fairy tales, bamileke tales":"nufi_contes_bamilekes",
        "La fourmi affamée : Ŋgə̂mbà – Français: Tə́ttá pfʉ́ njjikhwu’ú":"ngemba_fourmi_affamee"
    })

    # Iterate over the dictionary items
    for key, value in title_mappings.items():
        # If the title contains the key, return the associated new nickname
        if key in title:
            return value

    # If no mapping was found, return the title itself
    return title


def count_authors(x):
    if "resulam" in x.lower():
        return len(x.split(","))
    else:
        return len(x.split(","))+1

# def replace_author(row):
#     title_lower = row['Title'].lower()
#     if 'guide de conversation trilingue français-anglais-yemba' in title_lower:
#         return 'Giresse Jiokeng Feutsa, Oliver Germain Tafouemewe, Shck Tchamna'
#     elif pd.isnull(row['Authors']) or 'nùfī' in title_lower or 'nufi' in title_lower or "fe'efe'e" in title_lower:
#         return "Resulam, Shck Tchamna"
#     else:
#         return row['Authors']

# def count_authors(authors_str):
#     if pd.isnull(authors_str):
#         return 0
#     return len([author for author in authors_str.split(",") if author.strip()])


# Apply the function and update 'Authors' column
sell_this_year_2['Authors'] = sell_this_year_2.apply(replace_author, axis=1)
sell_history_2['Authors'] = sell_history_2.apply(replace_author, axis=1)

# Apply count_authors function to count the number of authors
sell_this_year_2['Authors Count'] = sell_this_year_2['Authors'].apply(count_authors)
sell_history_2['Authors Count'] = sell_history_2['Authors'].apply(count_authors)


royalties_df = sell_this_year_2
royalties_history_df = sell_history_2

# sell_this_year_2["Authors"].unique()

ISBN_Paper = [str(i) for i in ISBN_Paper]
ISBN_HardCovers = [str(i) for i in ISBN_HardCovers]

def get_book_type_from_ISBN(x):
    if x in ISBN_Paper:
        return "Paper"
    elif x in ISBN_HardCovers:
        return "HardCover"
    elif x in ASIN_Ebook:
        return "Ebook"
    else:
        return "U"  # or return None, depending on your preference

royalties_history_df["BookType"] = royalties_history_df["ASIN/ISBN"].apply(get_book_type_from_ISBN)
royalties_history_df
royalties_history_df["BookType"].unique()





royalties_history_df[royalties_history_df["Language"]=="Fongbe"]["Title"].unique()



royalties_history_df["Language"] = royalties_history_df["Language"].apply(lang_nufi)
royalties_history_df["book_nick_name"] = royalties_history_df["book_nick_name"].apply(replace_book_nick_name)



# royalties_history_df[royalties_history_df["Title"]=="Conte Africain -Fongbe: « Travaille aujourd’hui et mange demain, paresse aujourd’hui et vole demain »."]
# royalties_history_df[royalties_history_df["book_nick_name"] == "fongbe_conte_travaille_paresse"]



# Hypothetical exchange rates
exchange_rates = {
    'EUR': 1,  # 1 Euro = 1.1 USD
    'JPY': 0.0073,  # 1 Japanese Yen = 0.0073 USD
    'USD': 1,  # 1 USD = 1 USD (for completeness)
    "CAD" : 0.8,
    'GBP': 1.3,
    "BRL": 0.2,
    "AUD": 0.7,
"PLN": 0.25,
"SEK" : 0.1
}

exchange_rates = {
    'EUR': 1,  # 1 Euro = 1.1 USD
    'JPY': 0.0073,  # 1 Japanese Yen = 0.0073 USD
    'USD': 1,  # 1 USD = 1 USD
    "CAD": 0.8,  # 1 Canadian Dollar = 0.8 USD
    'GBP': 1.3,  # 1 British Pound = 1.3 USD
    "BRL": 0.2,  # 1 Brazilian Real = 0.2 USD
    "AUD": 0.7,  # 1 Australian Dollar = 0.7 USD
    "PLN": 0.25, # 1 Polish Zloty = 0.25 USD
    "SEK": 0.1,  # 1 Swedish Krona = 0.1 USD
    "INR": 0.0126 # 1 Indian Rupee = 0.0126  USD
}

# Function to convert currency to USD
def convert_to_usd(row):
    return row['Royalty'] * exchange_rates[row['Currency']]

# Convert Royalties to USD
royalties_df['Royalty USD'] = royalties_df.apply(convert_to_usd, axis=1)
# Calculate Royalty per Author
royalties_df['Royalty per Author (USD)'] = royalties_df['Royalty USD'] / royalties_df['Authors Count']
# Display the first few rows with the new columns
royalties_df[['Title', 'Authors', 'Currency', 'Royalty', 'Royalty USD', 'Authors Count', 'Royalty per Author (USD)']].head()

####################################

# Convert Royalties to USD
royalties_history_df['Royalty USD'] = royalties_history_df.apply(convert_to_usd, axis=1)
# Calculate Royalty per Author
royalties_history_df['Royalty per Author (USD)'] = royalties_history_df['Royalty USD'] / royalties_history_df['Authors Count']
# Display the first few rows with the new columns
royalties_history_df[['Title', "Language", 'Authors', 'Currency', 'Royalty', 'Royalty USD', 'Authors Count', 'Royalty per Author (USD)']].head()

"""# Save Processed Data"""

royalties_history_df.to_csv(f"royalties_resulambooks_from_2015_{last_year}_history_df.csv",encoding="utf 8-sig")

"""# Data Analysis"""



"""## Number of book sold per year"""





# Extract year from the 'Royalty Date' column
royalties_history_df['Year Sold'] = pd.to_datetime(royalties_history_df['Royalty Date']).dt.year

# Get the current year
current_year = datetime.now().year

# Exclude the current year from the analysis
royalties_history_df = royalties_history_df[royalties_history_df['Year Sold'] != current_year]

# Group by year and sum the 'Net Units Sold'
units_sold_by_year = royalties_history_df.groupby('Year Sold')['Net Units Sold'].sum().reset_index()

# Sort the DataFrame from biggest to smallest 'Net Units Sold'
units_sold_by_year = units_sold_by_year.sort_values(by='Net Units Sold', ascending=False)

# Create the plot with a white background
fig = px.bar(units_sold_by_year, x='Year Sold', y='Net Units Sold',
             title=f'Number of Books Sold sold by Resulam per Year, from 2015 to {current_year - 1}',
             labels={'Year Sold': 'Year Sold', 'Net Units Sold': 'Net Units Sold'}, text='Net Units Sold',
             template='plotly_white')

# Show the plot
fig.show()

# pip show nbformat





# import pandas as pd
# import plotly.express as px
# from datetime import datetime

# # Extract year from the 'Royalty Date' column
# royalties_history_df['Year Sold'] = pd.to_datetime(royalties_history_df['Royalty Date']).dt.year

# # Exclude the current year
# current_year = datetime.now().year
# royalties_history_df = royalties_history_df[royalties_history_df['Year Sold'] != current_year]

# # Group by year and language, and sum the 'Net Units Sold'
# units_sold_by_year_language = royalties_history_df.groupby(['Year Sold', 'Language'])['Net Units Sold'].sum().reset_index()

# # Create an interactive plot with discrete years on the x-axis
# fig = px.bar(units_sold_by_year_language, x='Year Sold', y='Net Units Sold', color='Language',
#              title=f'Number of Books Sold from 2015 to {current_year - 1} by Language',
#              labels={'Year Sold': 'Year Sold', 'Net Units Sold': 'Net Units Sold'},
#              template='plotly_white',
#              category_orders={"Year Sold": sorted(units_sold_by_year_language['Year Sold'].unique())})

# # Get unique languages
# unique_languages = units_sold_by_year_language['Language'].unique()

# # Create a boolean array for the visibility of each language
# traces = []
# for lang in unique_languages:
#     visible = units_sold_by_year_language['Language'] == lang
#     traces.extend([True if v else False for v in visible])

# # Update layout for dropdown
# language_buttons = []
# for i, lang in enumerate(unique_languages):
#     visibility = [False] * len(unique_languages) * len(units_sold_by_year_language['Year Sold'].unique())
#     visibility[i::len(unique_languages)] = [True] * len(units_sold_by_year_language['Year Sold'].unique())
#     language_buttons.append(dict(label=lang, method="update", args=[{"visible": visibility}]))

# # Add an 'All' button
# all_button = dict(args=[{"visible": [True] * len(traces)}], label="All", method="update")

# fig.update_layout(
#     updatemenus=[
#         dict(
#             buttons=[all_button] + language_buttons,
#             direction="down",
#             showactive=True,
#         )
#     ]
# )

# # Show the plot
# fig.show()





# Extract year from the 'Royalty Date' column
royalties_history_df['Year Sold'] = pd.to_datetime(royalties_history_df['Royalty Date']).dt.year

# Exclude the current year
current_year = datetime.now().year
royalties_history_df = royalties_history_df[royalties_history_df['Year Sold'] != current_year]

# Group by year and language, and sum the 'Net Units Sold'
units_sold_by_year_language = royalties_history_df.groupby(['Year Sold', 'Language'])['Net Units Sold'].sum().reset_index()


# Assuming royalties_history_df is defined and contains 'Royalty Date', 'Language', and 'Net Units Sold' columns
units_sold_by_yearld_by_year_language = royalties_history_df.groupby(['Year Sold', 'Language'])['Net Units Sold'].sum().reset_index()

# Extract year from the 'Royalty Date' column and exclude the current year
royalties_history_df['Year Sold'] = pd.to_datetime(royalties_history_df['Royalty Date']).dt.year
current_year = datetime.now().year
royalties_history_df = royalties_history_df[royalties_history_df['Year Sold'] != current_year]

# Group by year and language, and sum the 'Net Units Sold'

excluded_languages = ['Bamileke', 'Africa']
units_sold_by_year_language = units_sold_by_year_language[~units_sold_by_year_language['Language'].isin(excluded_languages)]

# Sort languages alphabetically after excluding
sorted_languages = sorted(units_sold_by_year_language['Language'].unique())

# Create a Plotly figure with stacked bars initially
fig = go.Figure()

# Add a bar trace for each language
for language in sorted_languages:
    filtered_df = units_sold_by_year_language[units_sold_by_year_language['Language'] == language]
    fig.add_trace(go.Bar(
        x=filtered_df['Year Sold'],
        y=filtered_df['Net Units Sold'],
        name=language
    ))

# Create dropdown buttons
dropdown_buttons = [
    {'label': 'All (Stacked)', 'method': 'update',
     'args': [{'visible': [True] * len(sorted_languages)}, {'barmode': 'stack'},
              {'title': 'Resulam Number of Books Sold by Language per Year', 'text': [None] * len(sorted_languages)}]},
]

for i, language in enumerate(sorted_languages):
    visibility = [False] * len(sorted_languages)
    visibility[i] = True
    text_labels = [None] * len(sorted_languages)
    text_labels[i] = units_sold_by_year_language[units_sold_by_year_language['Language'] == language]['Net Units Sold']
    dropdown_buttons.append(
        {'label': language, 'method': 'update',
         'args': [{'visible': visibility}, {'barmode': 'group'}, {'title': f'Books Sold in {language}', 'text': text_labels}]}
    )

# Update layout for dropdown and initial stacked mode
fig.update_layout(
    plot_bgcolor='rgba(255,255,255,1)',
    paper_bgcolor='rgba(255,255,255,1)',
    updatemenus=[
        dict(
            buttons=dropdown_buttons,
            direction='down',
            showactive=True,
            x=0.9,
            xanchor='right',
            y=1.15,
            yanchor='top'
        )
    ],
    title='Number of Books Sold by Language',
    xaxis_title='Year Sold',
    yaxis_title='Net Units Sold',
    barmode='stack'
)

# Add text to bars for specific language view
for i, trace in enumerate(fig.data):
    trace.text = units_sold_by_year_language[units_sold_by_year_language['Language'] == sorted_languages[i]]['Net Units Sold']
    trace.textposition = 'inside'

# Show the plot
fig.show()




from datetime import datetime

def barplot(royalties_history_df,field_of_interest = 'Language'):

    # Extract year from the 'Royalty Date' column
    royalties_history_df['Year Sold'] = pd.to_datetime(royalties_history_df['Royalty Date']).dt.year

    # Exclude the current year
    current_year = datetime.now().year
    royalties_history_df = royalties_history_df[royalties_history_df['Year Sold'] != current_year]

    # Group by year and language, and sum the 'Net Units Sold'
    units_sold_by_year_language = royalties_history_df.groupby(['Year Sold', field_of_interest])['Net Units Sold'].sum().reset_index()


    # Assuming royalties_history_df is defined and contains 'Royalty Date', 'Language', and 'Net Units Sold' columns
    units_sold_by_yearld_by_year_language = royalties_history_df.groupby(['Year Sold', field_of_interest])['Net Units Sold'].sum().reset_index()

    # Extract year from the 'Royalty Date' column and exclude the current year
    royalties_history_df['Year Sold'] = pd.to_datetime(royalties_history_df['Royalty Date']).dt.year
    current_year = datetime.now().year
    royalties_history_df = royalties_history_df[royalties_history_df['Year Sold'] != current_year]

    # Group by year and language, and sum the 'Net Units Sold'

    excluded_languages = ['Bamileke', 'Africa']
    units_sold_by_year_language = units_sold_by_year_language[~units_sold_by_year_language[field_of_interest].isin(excluded_languages)]

    # Sort languages alphabetically after excluding
    sorted_languages = sorted(units_sold_by_year_language[field_of_interest].unique())

    # Create a Plotly figure with stacked bars initially
    fig = go.Figure()

    # Add a bar trace for each language
    for language in sorted_languages:
        filtered_df = units_sold_by_year_language[units_sold_by_year_language[field_of_interest] == language]
        fig.add_trace(go.Bar(
            x=filtered_df['Year Sold'],
            y=filtered_df['Net Units Sold'],
            name=language
        ))

    # Create dropdown buttons
    dropdown_buttons = [
        {'label': 'All (Stacked)', 'method': 'update',
         'args': [{'visible': [True] * len(sorted_languages)}, {'barmode': 'stack'},
                  {'title': f'Resulam Number of Books Sold by Language per Year', 'text': [None] * len(sorted_languages)}]},
    ]

    for i, language in enumerate(sorted_languages):
        visibility = [False] * len(sorted_languages)
        visibility[i] = True
        text_labels = [None] * len(sorted_languages)
        text_labels[i] = units_sold_by_year_language[units_sold_by_year_language[field_of_interest] == language]['Net Units Sold']
        dropdown_buttons.append(
            {'label': language, 'method': 'update',
             'args': [{'visible': visibility}, {'barmode': 'group'}, {'title': f'Books Sold in {language}', 'text': text_labels}]}
        )

    # Update layout for dropdown and initial stacked mode
    fig.update_layout(
        plot_bgcolor='rgba(255,255,255,1)',
        paper_bgcolor='rgba(255,255,255,1)',
        updatemenus=[
            dict(
                buttons=dropdown_buttons,
                direction='down',
                showactive=True,
                x=0.9,
                xanchor='right',
                y=1.15,
                yanchor='top'
            )
        ],
        title=f'Number of Books Sold per {field_of_interest}',
        xaxis_title='Year Sold',
        yaxis_title='Net Units Sold',
        barmode='stack'
    )

    # Add text to bars for specific language view
    for i, trace in enumerate(fig.data):
        trace.text = units_sold_by_year_language[units_sold_by_year_language[field_of_interest] == sorted_languages[i]]['Net Units Sold']
        trace.textposition = 'inside'

    # Show the plot
    fig.show()

barplot(royalties_history_df,field_of_interest = 'book_nick_name')



"""## Type of book sold"""







def plot_books_sold_by_title_horizontal(royalties_df):
    # Group by title and sum the net units sold
    units_sold_by_title = royalties_df.groupby('book_nick_name')['Net Units Sold'].sum().reset_index()

    # Sort the DataFrame by net units sold in descending order for better visibility
    units_sold_by_title = units_sold_by_title.sort_values(by='Net Units Sold', ascending=True)

    # Create a Plotly figure
    fig = go.Figure()

    # Add a horizontal bar trace
    fig.add_trace(go.Bar(
        y=units_sold_by_title['book_nick_name'],
        x=units_sold_by_title['Net Units Sold'],
        orientation='h'  # This creates a horizontal bar plot
    ))

    # Update layout
    fig.update_layout(
        title='Number of Books Sold by Title',
        yaxis_title='book_nick_name',
        xaxis_title='Net Units Sold'
    )

    # Show the plot
    fig.show()

# Call the function with the DataFrame
plot_books_sold_by_title_horizontal(royalties_history_df)







def plot_books_sold_by_title_horizontal(royalties_df):
    # Extract year from 'Royalty Date' and add as a new column
    royalties_df['Year Sold'] = pd.to_datetime(royalties_df['Royalty Date']).dt.year

    # Sort years for the dropdown
    sorted_years = sorted(royalties_df['Year Sold'].unique())

    # Create the figure object
    fig = go.Figure()

    for year in sorted_years:
        # Filter the DataFrame for the selected year
        df_filtered = royalties_df[royalties_df['Year Sold'] == year]

        # Group by title and sum the net units sold for the filtered DataFrame
        units_sold_by_title = df_filtered.groupby('book_nick_name')['Net Units Sold'].sum().reset_index()

        # Sort by net units sold in ascending order
        units_sold_by_title = units_sold_by_title.sort_values(by='Net Units Sold', ascending=True)

        # Add a bar trace for each year
        fig.add_trace(go.Bar(
            y=units_sold_by_title['book_nick_name'],
            x=units_sold_by_title['Net Units Sold'],
            orientation='h',
            name=str(year)  # Use the year as the name for the trace
        ))

    # Create dropdown buttons for year filtering
    dropdown_buttons = [
        {'label': str(year), 'method': 'update',
         'args': [{'visible': [year == y for y in sorted_years]},
                  {'title': f'Number of Books Sold by Title in {year}'}]}
        for year in sorted_years
    ]

    # Add 'Show All' option to the dropdown
    dropdown_buttons.append(
        {'label': 'Show All', 'method': 'update',
         'args': [{'visible': [True] * len(sorted_years)},  # Set all traces to visible
                  {'title': 'Number of Books Sold by Title'}]}
    )

    # Update layout to include dropdown
    fig.update_layout(
        updatemenus=[{
            'buttons': dropdown_buttons,
            'direction': 'down',
            'x': 0.5,
            'xanchor': 'center',
            'y': 1.2,
            'yanchor': 'top'
        }],
        title='Number of Books Sold by Title',
        yaxis_title='book_nick_name',
        xaxis_title='Net Units Sold',
        showlegend=False  # Hide the legend if not necessary
    )

    # Show the plot
    fig.show()

# Call the function with the DataFrame
plot_books_sold_by_title_horizontal(royalties_history_df)







# Assuming royalties_history_df is your DataFrame

app = dash.Dash(__name__)

app.layout = html.Div([
    dcc.Input(id='book-name-input', type='text', placeholder='Enter a book name'),
    dcc.Graph(id='books-sold-plot')
])

@app.callback(
    Output('books-sold-plot', 'figure'),
    [Input('book-name-input', 'value')]
)
def update_graph(book_name):
    try:
        fig = go.Figure()

        # Iterate through each year and create a trace
        for year in sorted(royalties_history_df['Year Sold'].unique()):
            # Filter DataFrame based on the book name input and year
            if book_name:
                filtered_df = royalties_history_df[
                    (royalties_history_df['book_nick_name'].str.contains(book_name, case=False, na=False)) &
                    (royalties_history_df['Year Sold'] == year)
                ]
            else:
                # If no book name is entered, display data for the year
                filtered_df = royalties_history_df[royalties_history_df['Year Sold'] == year]

            # Add a trace for the filtered data
            fig.add_trace(go.Bar(
                x=filtered_df['book_nick_name'],
                y=filtered_df['Net Units Sold'],
                name=str(year)  # Use year as the trace name
            ))

        # Update plot layout
        fig.update_layout(
            title='Number of Books Sold by Title',
            xaxis_title='Title',
            yaxis_title='Net Units Sold',
            legend_title="Year"
        )

        return fig
    except Exception as e:
        print(f"An error occurred: {e}")
        # Return an empty figure or error message in case of an exception
        return go.Figure()

if __name__ == '__main__':
    app.run_server(debug=True)





# Assuming royalties_history_df is your DataFrame

app = dash.Dash(__name__)

app.layout = html.Div([
    dcc.Input(id='book-name-input', type='text', placeholder='Enter a book name'),
    dcc.Graph(id='books-sold-plot')
])

@app.callback(
    Output('books-sold-plot', 'figure'),
    [Input('book-name-input', 'value')]
)
def update_graph(book_name):
    try:
        # Filter DataFrame based on the book name input
        if book_name:
            filtered_df = royalties_history_df[royalties_history_df['book_nick_name'].str.contains(book_name, case=False, na=False)]
        else:
            # If no book name is entered, display the full dataset
            filtered_df = royalties_history_df

        # Plotting code using filtered_df
        fig = go.Figure(data=[
            go.Bar(
                x=filtered_df['book_nick_name'],  # Adjust column names as needed
                y=filtered_df['Net Units Sold']   # Adjust column names as needed
            )
        ])
        fig.update_layout(title='Number of Books Sold by Title', xaxis_title='Title', yaxis_title='Net Units Sold')

        return fig
    except Exception as e:
        print(f"An error occurred: {e}")
        # Return an empty figure or error message in case of an exception
        return go.Figure()

if __name__ == '__main__':
    # app.run_server(debug=True)
    app.run(debug=True)







"""# Total Book Sold By Resulam History"""



royalties_history_df["Net Units Sold"].sum()



TotalRevenue = royalties_history_df["Royalty USD"].sum()
TotalRevenue = round(TotalRevenue,2)
Total_shared = royalties_history_df["Royalty per Author (USD)"].sum()
Total_shared = round(Total_shared,2)

Resulam_share = TotalRevenue - Total_shared
TotalRevenue,Total_shared, Resulam_share



"""# Authors Individual Impact

**Notice on Authors' Individual Impact Analysis**
<br>Please be aware that in this section, we will be expanding the dataset to analyze each author's individual contribution. This process involves "exploding" the data, which means creating duplicate rows for entries with multiple authors. Each author will be represented separately to accurately assess their individual contributions.

Important Caution: Due to this duplication of rows, the data in this section should not be used for overall metrics or global analyses. It is specifically tailored for individual author impact assessment and might lead to misleading conclusions if used for broader metrics. Keep this in mind when interpreting the results from this section.






"""



"""## Explode Authors Field"""

royalties_df['Authors'].unique()



# Exploding the 'Authors' column to create a separate row for each author per book
# Assuming the authors are separated by a comma in the 'Authors' column

# df_exploded = royalties_df.assign(Authors=royalties_df['Authors'].str.split(',')).explode('Authors')

# Split the 'Authors' column into a list of authors
royalties_df['Authors_Exploded'] = royalties_df['Authors'].str.strip().str.split(',')
royalties_history_df['Authors_Exploded'] = royalties_history_df['Authors'].str.strip().str.split(',')

# Explode the 'Authors' list into separate rows
royalties_df_exploded = royalties_df.explode('Authors_Exploded')
royalties_df_exploded['Authors_Exploded'] = royalties_df_exploded['Authors_Exploded'].str.strip()

# Explode the 'Authors' list into separate rows
royalties_history_df_exploded = royalties_history_df.explode('Authors_Exploded')
royalties_history_df_exploded['Authors_Exploded'] = royalties_history_df_exploded['Authors_Exploded'].str.strip()
# Displaying the first few rows of the exploded dataframe
# royalties_df_exploded.to_csv("royalties_df_exploded.csv",encoding="utf 8-sig")
display(royalties_df_exploded.tail(2))

royalties_history_df_exploded.head(2)

royalties_history_df_exploded.tail(2)





# royalties_df["Net Units Sold"].sum()
# royalties_df_exploded["Authors_Exploded"] = royalties_df_exploded["Authors_Exploded"].apply(lambda x: x.strip())

# # royalties_df_exploded["Net Units Sold"].sum()
# sorted(royalties_df_exploded["Authors_Exploded"].unique())




author_names_dict = {
    "Shck Shck Tchamna":"Shck Tchamna",
    "Shck Shck Tchamna":"Shck Tchamna",
    "Shck Ca᷅mnà'":"Shck Tchamna",
    "Shck Cǎmnà'":"Shck Tchamna",

    "Claude Lionel Mvondo Edzoa": "Claude Lionel Mvondo",
    "IMELE TSAFACK": "Imele Tsafack",
    "Tsafack Imele": "Imele Tsafack",
    "Jean rene Djobia":"Jean René Djobia",
    "Tanyi Djobia Rene":"Jean René Djobia",
    "Joseph Oyange Wajuanga":"Joseph Oyange",
    "Josephine Ndonke":"Joséphine Ndonke",
    "Pascaline Motoum":"Mə̂fo Gòmlù’ Motoum",
    "Oliver Germain Tafouemewe":"Olivier Tafouemewe",
    "Zachée Denis BITJAA KODY":"Pr Zachée Denis BITJAA KODY",
    "Zachee Bitjaa Kody":"Pr Zachée Denis BITJAA KODY",
    "Iyo Ngobo Ekwalla":"Ngobo Ekwala",
    "Resulam Resulam":"Resulam",


}



"""## Cleaning Authors' names"""

# royalties_df_exploded["Authors_Exploded"].apply(clean_author_names)
royalties_df_exploded['Authors_Exploded'] = royalties_df_exploded['Authors_Exploded'].replace(author_names_dict)

royalties_history_df_exploded['Authors_Exploded'] = royalties_history_df_exploded['Authors_Exploded'].replace(author_names_dict)


# unique_authors = sorted(royalties_df_exploded['Authors_Exploded'].replace(author_names_dict).unique())

unique_authors = royalties_history_df_exploded['Authors_Exploded'].unique()
unique_authors_history = royalties_df_exploded['Authors_Exploded'].unique()

# sorted(list(unique_authors))

len(unique_authors_history)

# Grouping the exploded DataFrame by 'Authors_Exploded' and calculating the sum
# Then resetting the index and selecting specific columns
grouped_df = royalties_df_exploded.groupby("Authors_Exploded").sum().reset_index()
royalties_df_ = grouped_df[["Authors_Exploded", "Units Sold", "Royalty USD", "Royalty per Author (USD)"]]


royalties_df_ = royalties_df_.sort_values(by="Royalty per Author (USD)").reset_index(drop=True)
royalties_df_

# Grouping the exploded DataFrame by 'Authors_Exploded' and calculating the sum
# Then resetting the index and selecting specific columns
grouped_df_history = royalties_history_df_exploded.groupby("Authors_Exploded").sum().reset_index()
royalties_df_history = grouped_df_history[["Authors_Exploded", "Units Sold", "Royalty USD", "Royalty per Author (USD)"]]


royalties_df_history = royalties_df_history.sort_values(by="Royalty per Author (USD)").reset_index(drop=True)
royalties_df_history

grouped_df_history_count = royalties_history_df_exploded.groupby("Authors_Exploded").count().reset_index()
grouped_df_history_count = grouped_df_history_count[["Authors_Exploded","Units Sold"]].sort_values(by = "Units Sold")
grouped_df_history_count


"""# Adjusted Royalties"""


adjusted_amount = 5 # IN USD

def adjust_royalties(x):
    if x< 100:
        return round(x+adjusted_amount,2)
    else:
        return round(x,2)

royalties_per_author_final = royalties_df_[["Authors_Exploded","Units Sold","Royalty per Author (USD)"]].copy()

royalties_per_author_final["Royalty per Author (USD)"] = \
royalties_per_author_final["Royalty per Author (USD)"].apply(adjust_royalties)

royalties_per_author_final = royalties_per_author_final.rename(columns={"Authors_Exploded":"Authors"})

# royalties_per_author_final_to_share.index = range(1, len(royalties_per_author_final_to_share) + 1)

display(royalties_per_author_final)

msk = royalties_per_author_final["Authors"] != "Shck Tchamna"
royalties_per_author_final_to_share = royalties_per_author_final[msk]
royalties_per_author_final_to_share

royalties_per_author_final_to_share.index = range(1, len(royalties_per_author_final_to_share) + 1)

conversion_rate = 500 # your conversion rate to XAF
royalties_per_author_final_to_share['Royalty per Author (FCFA)'] = royalties_per_author_final_to_share['Royalty per Author (USD)'] * conversion_rate
royalties_per_author_final_to_share

royalties_per_author_final_to_share["Authors"].unique()



royalties_per_author_final_to_share.to_csv(f"royalties_per_author_final_to_share_{last_year}.csv",encoding="utf 8-sig")



"""# NOTEBOOK

# Import Data
"""



# pip install dash
# pip install openpyxl
# pip install pandas
# pip install plotly

# pip install --upgrade nbformat



# from google.colab import drive
# drive.mount('/content/drive')



# books = pd.read_csv(resulam_books_path, encoding='latin1')
# books = pd.read_csv(resulam_books_path, encoding='utf-8', on_bad_lines='skip')
# books = pd.read_csv(resulam_books_path, encoding='ISO-8859-1', on_bad_lines='skip')



# Apply the dictionary mapping to the 'Author Name' column
# sell_this_year['Author Name'] = sell_this_year['Author Name'].map(dict_normalize_names).fillna(sell_this_year['Author Name'])
# Remove leading and trailing spaces from the 'Author Name' column

# dict_normalize_names = {
#     "Rodrigue": "Shck",
#     "Shck Shck": "Shck",
#     "Rodrigue Tchamna": "Shck Tchamna",
#     "Zachée Denis BITJAA  KODY": "Zachée Denis BITJAA KODY",
#     "Zachee Bitjaa Kody": "Zachée Denis BITJAA KODY",
#     'Resulam Resulam': "Resulam",
#     "Jean rene Djobia": "Tanyi Djobia René",
#     "Jean René Djobia": "Tanyi Djobia René",
#     "Tanyi Djobia Rene": "Tanyi Djobia René",

#     'Tchamna': "Shck Tchamna",
#     "Mə̂fo Gòmlù’ Gòmlù’ Motoum": "Mə̂fò Gòmlù'",
#     "Pascaline Motoum": "Mə̂fò Gòmlù'",
#     'SHCK Tchamna': "Shck Tchamna",
#     "Claude Lionel Mvondo" :" Claude Lionel Mvondo Edzoa"
# }

# sell_this_year['Author Name'] = sell_this_year['Author Name'].str.strip()
# sell_this_year['Author Name'] = sell_this_year['Author Name'].apply(lambda x: dict_normalize_names.get(x, x))

# sell_history = pd.read_excel(royalties_resulam_history_path,sheet_name="Combined Sales")

# sell_history['Author Name'].unique()

import pandas as pd
import re
from datetime import datetime

current_year = datetime.now().year
last_year = current_year - 1


# main_dir = r"G:\My Drive\Mbú'ŋwɑ̀'nì\RoyaltiesResulam"

# resulam_books_path = main_dir + r"\Resulam_books_database_Amazon_base_de_donnee_livres.csv"
# royalties_resulam_path = main_dir + fr"\KDP_OrdersResulamBookSales{last_year}RoyaltiesReports.xlsx"
# royalties_resulam_history_path = main_dir + f"\KDP_OrdersResulamBookSales2015_{last_year}RoyaltiesReportsHistory.xlsx"

resulam_books_path = fr"/content/drive/MyDrive/Mbú'ŋwɑ̀'nì/RoyaltiesResulam/Resulam_books_database_Amazon_base_de_donnee_livres.csv"
resulam_books_path_xls = fr"/content/drive/MyDrive/Mbú'ŋwɑ̀'nì/RoyaltiesResulam/Resulam_books_database_Amazon_base_de_donnee_livres.xlsx"

royalties_resulam_path =  f"/content/drive/MyDrive/Mbú'ŋwɑ̀'nì/RoyaltiesResulam/KDP_OrdersResulamBookSales{last_year}RoyaltiesReports.xlsx"
royalties_resulam_history_path = f"/content/drive/MyDrive/Mbú'ŋwɑ̀'nì/RoyaltiesResulam/KDP_OrdersResulamBookSales2015_{last_year}RoyaltiesReportsHistory.xlsx"

books = pd.read_csv(resulam_books_path)

sell_this_year = pd.read_excel(royalties_resulam_path,sheet_name="Combined Sales")
sell_history = pd.read_excel(royalties_resulam_history_path,sheet_name="Combined Sales")

sell_history_ebook = pd.read_excel(royalties_resulam_history_path,sheet_name="eBook Royalty")
sell_history_paper = pd.read_excel(royalties_resulam_history_path,sheet_name="Paperback Royalty")
sell_history_hardcover = pd.read_excel(royalties_resulam_history_path,sheet_name="Hardcover Royalty")

ASIN_Ebook = sell_history_ebook["ASIN"].unique()
ISBN_Paper = sell_history_paper["ISBN"].unique()
ISBN_HardCovers = sell_history_hardcover["ISBN"].unique()



author_names_dict = {
    "Rodrigue": "Shck",
    "Shck Shck": "Shck",
    "Rodrigue Tchamna": "Shck Tchamna",
    "Zachée Denis BITJAA  KODY": "Pr Zachée Denis BITJAA KODY",
    "Zachee Bitjaa Kody": "Pr Zachée Denis BITJAA KODY",
    'Resulam Resulam': "Resulam",
    "Jean rene Djobia": "Tanyi Djobia René",
    "Jean René Djobia": "Tanyi Djobia René",
    "Tanyi Djobia Rene": "Tanyi Djobia René",

    'Tchamna': "Shck Tchamna",
    "Mə̂fo Gòmlù’ Gòmlù’ Motoum": "Mə̂fo Gòmlù’ Motoum",
    "Pascaline Motoum": "Mə̂fo Gòmlù’ Motoum",
    'SHCK Tchamna': "Shck Tchamna",
    "Claude Lionel Mvondo" :" Claude Lionel Mvondo Edzoa",
    "IMELE TSAFACK": "Imele Tsafack",
    "Tsafack Imele": "Imele Tsafack",
    "Joseph Oyange Wajuanga":"Joseph Oyange",
    "Josephine Ndonke":"Joséphine Ndonke",
     "Iyo Ngobo Ekwalla":"Ngobo Ekwala",
    "Oliver Germain Tafouemewe":"Olivier Tafouemewe",


}

# author_names_dict = {
#     "Shck Shck Tchamna":"Shck Tchamna",
#     "Shck Shck Tchamna":"Shck Tchamna",
#     "Shck Ca᷅mnà'":"Shck Tchamna",
#     "Shck Cǎmnà'":"Shck Tchamna",

#     "Claude Lionel Mvondo Edzoa": "Claude Lionel Mvondo",
#     "IMELE TSAFACK": "Imele Tsafack",
#     "Tsafack Imele": "Imele Tsafack",
#     "Jean rene Djobia":"Jean René Djobia",
#     "Tanyi Djobia Rene":"Jean René Djobia",
#     "Joseph Oyange Wajuanga":"Joseph Oyange",
#     "Josephine Ndonke":"Joséphine Ndonke",
#     "Pascaline Motoum":"Mə̂fo Gòmlù’ Motoum",
#     "Oliver Germain Tafouemewe":"Olivier Tafouemewe",
#     "Zachée Denis BITJAA KODY":"Pr Zachée Denis BITJAA KODY",
#     "Zachee Bitjaa Kody":"Pr Zachée Denis BITJAA KODY",
#     "Iyo Ngobo Ekwalla":"Ngobo Ekwala",


# }

#Rename Authors, Names Normalization
sell_this_year['Author Name'] = sell_this_year['Author Name'].str.strip()
sell_this_year['Author Name'] = sell_this_year['Author Name'].apply(lambda x: author_names_dict.get(x, x))


# Function to strip and replace multiple spaces
def strip_and_replace_spaces(cell):
    if isinstance(cell, str):
        cell = cell.strip()  # Strip leading and trailing spaces
        cell = re.sub(r'\s+', ' ', cell)  # Replace multiple spaces with a single space
    return cell

# Apply the function to each element in the DataFrame
sell_history = sell_history.applymap(strip_and_replace_spaces)

# Apply the function to each element in the DataFrame
# sell_this_year = sell_this_year.apply(lambda x: x.replace("Rodrigue","Shck"))
# sell_this_year = sell_this_year.apply(lambda x: x.replace("Shck Shck","Shck"))
# sell_this_year = sell_this_year.apply(lambda x: x.replace("Ca᷅mnà'","Tchamna"))

books = books.rename(columns={"title":"Title"})
# books = books.apply(lambda x: x.replace("Rodrigue","Shck"))
# books = books.apply(lambda x: x.replace("Shck Shck","Shck"))
# books = books.apply(lambda x: x.replace("Ca᷅mnà'","Tchamna"))




rename_dict = {"Conversation de base": "Conversations de base",
               "Guide de conversation trilingue français-anglais-yemba": "Guide de conversation trilingue français-anglais-yemba: French-Yemba-English Phrasebook"}

for key, value in rename_dict.items():
    sell_this_year["Title"] = sell_this_year["Title"].str.replace(key, value)
    sell_history["Title"] = sell_history["Title"].str.replace(key, value)

for key, value in rename_dict.items():
    books["Title"] = books["Title"].str.replace(key, value)

books["Title"] = books["Title"].apply(lambda x: x.split("–")[0].strip())

sell_this_year["Title"] = sell_this_year["Title"].apply(lambda x: x.strip())
sell_history["Title"] = sell_history["Title"].apply(lambda x: x.strip())



# sell_history_paper["ISBN"]

# books
# sell_this_year

# sell_this_year["Title"].unique()







print(f"Number of Paper Book: {len(ISBN_Paper)}")
print(f"Number of Hard cover Book: {len(ISBN_HardCovers)}")
print(f"Number of Ebooks: {len(ASIN_Ebook)}")



books.head(2)

sell_this_year.head(2)

sell_history.head(2)

sell_this_year["Title"].loc[0]

def lang_nufi(x):
    if "nùfī" in x.lower() or "nufi" in x.lower() or "fe'efe'e" in x.lower() or "Nzhìèkǔ’ mɑ̀nkō ngʉ́ngà'" in x:
        return "Nufi"
    elif "medumba" in x.lower():
        return "Medumba"
    elif "yemba" in x.lower():
        return "Yemba"
    elif "yoruba" in x.lower():
        return "Yoruba"
    elif "duala" in x.lower():
        return "Duala"
    elif "yoruba" in x.lower():
        return "Yoruba"
    elif "fongbe" in x.lower():
        return "Fongbe"
    elif "Ŋgə̂mbà" in x:
        return "Ngemba"
    else:
        return x

#     Yoruba  Attic: Le Grenier du Yoruba: Òkè Àjà Yorùbá





# len(books['authors'])
# # len( books['Title'])





# Extracting the columns as lists
titles = books['Title'].tolist()
book_nick_names = books['book_nick_name'].tolist()
book_authors = books['authors'].tolist()
book_language_names = books['language_name'].tolist()


# Creating the dictionary using zip
books_nicknames_dict = dict(zip(titles, book_nick_names))
books_authors_dict = dict(zip(titles, book_authors))
books_languages_dict = dict(zip(titles, book_language_names))

books_languages_dict.update({})

# books_nicknames_dict
books_authors_dict;



# sell_this_year_2

sell_this_year_2.apply(replace_author, axis=1)

# sell_history["Authors"].unique()

# sell_this_year["book_nick_name"] = sell_this_year["Title"].apply(lambda x: books_nicknames_dict[x]
# #                                                        if x in books_nicknames_dict else x )

# sell_this_year["Authors"] = sell_this_year["Title"].apply(lambda x: books_authors_dict[x]
#                                                        if x in books_authors_dict else None )

# sell_this_year["Languages"] = sell_this_year["Title"].apply(lambda x: books_languages_dict[x]
#                                                        if x in books_languages_dict else None )
sell_this_year["book_nick_name"] = sell_this_year["Title"].replace(books_nicknames_dict)
sell_this_year["Authors"] = sell_this_year["Title"].replace(books_authors_dict)
sell_this_year["Language"] = sell_this_year["Title"].replace(books_languages_dict)

# sell_history["book_nick_name"] = sell_history["Title"].apply(lambda x: books_nicknames_dict[x]
#                                                        if x in books_nicknames_dict else x )

# sell_history["Authors"] = sell_history["Title"].apply(lambda x: books_authors_dict[x]
#                                                        if x in books_authors_dict else None )

sell_history["book_nick_name"] = sell_history["Title"].replace(books_nicknames_dict)
sell_history["Authors"] = sell_history["Title"].replace(books_authors_dict)
sell_history["Language"] = sell_history["Title"].replace(books_languages_dict)

# mask = sell_this_year["Authors"].apply(lambda x: True if x is None else False)
# sell_this_year[mask]

col_interest = ["Royalty Date", "Title","ASIN/ISBN", "Language", "book_nick_name","Authors", "Units Sold", "Units Refunded", "Net Units Sold",
                "Marketplace","Royalty Type","Transaction Type","Royalty","Currency",
                ]

sell_this_year_2 = sell_this_year[col_interest].copy()
# sell_this_year_2.sort_values(by="Royalty Date",ascending=False)

sell_history_2 = sell_history[col_interest].copy()
# sell_this_year_2.sort_values(by="Royalty Date",ascending=False)


def replace_author(x):
    if 'Guide de conversation trilingue français-anglais-yemba' in x['Title']:
        return 'Giresse Jiokeng Feutsa, Oliver Germain Tafouemewe, Shck Tchamna'
    elif "Contes bamilekés racontés en medumba et traduits en français (Black and White)" in x["Title"]:
        return "Leopold Tchoumi"

    elif "Yoruba - French - English Phrasebook: Guide de conversation Yoruba – Français - Anglais" in x["Title"]:
        return "Resulam, Shck Tchamna"

    elif "Le Grenier du Nguemba: Ntâŋ Ŋgə̂mbà : Ngemba Attic" in x["Title"]:
        return "Deeh Segallo, Resulam, Shck Tchamna"

    elif "La fourmi affamée: Nzhìèkǔ’ mɑ̀nkō ngʉ́ngà'" in x["Title"]:
        return "Resulam, Shck Tchamna"


    elif x['Authors'] is None:
        return "Resulam, Shck Tchamna"
    elif "nùfī" in x['Title'].lower() or "nufi" in x['Title'].lower() or "fe'efe'e" in x['Title'].lower():
        return "Resulam, Shck Tchamna"
    elif "nùfī" in x['Title'].lower():
        return "Resulam, Shck Tchamna"
    else:
        return x['Authors']

# def replace_book_nick_name(x):
#     if "Nùfī Attic - Le Grenier du Nùfī - KAM 1: Ntǎ' Nùfī" in x['Title']:
#         return 'NtaNufi_Ebook'
#     elif "Nùfī Attic - Le Grenier du Nùfī - KAM 2: Ntǎ' Nùfī" in x['Title']:
#         return 'NtaNufi_Ebook'
#     elif "Nùfī Attic - Le Grenier du Nùfī - KAM 3: Ntǎ' Nùfī" in x['Title']:
#         return 'NtaNufi_Ebook'
#     elif "Nùfī Attic - Le Grenier du Nùfī - KAM 4: Ntǎ' Nùfī" in x['Title']:
#         return 'NtaNufi_Ebook'
#     elif "Nùfī Attic - Le Grenier du Nùfī - KAM 5: Ntǎ' Nùfī" in x['Title']:
#         return 'NtaNufi_Ebook'
#     elif "Nùfī Attic - Le Grenier du Nùfī - KAM 6: Ntǎ' Nùfī" in x['Title']:
#         return 'NtaNufi_Ebook'
#     elif "Nùfī Attic - Le Grenier du Nùfī - KAM 7: Ntǎ' Nùfī" in x['Title']:
#         return 'NtaNufi_Ebook'
#     elif "Nùfī Attic - Le Grenier du Nùfī - KAM 8: Ntǎ' Nùfī" in x['Title']:
#         return 'NtaNufi_Ebook'

#     elif "Ntǎ' Nùfī - Nùfī Attic - Le Grenier du Nùfī (Version sans audio)" in x['Title']:
#         return 'NtaNufi_Ebook'
#     elif "Guide de conversation trilingue Français-anglais-fe'efe'e.: French-Fè'éfě'è-English Phrasebook" in x['Title']:
#         return 'nufi_phrasebook'
#     elif "La grammaire des langues bamilekes : cas du nufi" in x['Title']:
#         return 'nufi_grammaire'



#     else:
#         return x['Title']


def replace_book_nick_name(title):
    # A dictionary mapping unique parts of titles to their new nicknames
    title_mappings = {f"Nùfī Attic - Le Grenier du Nùfī - KAM {i}:": "nufi_attic_interactive" for i in range(1, 9)}
    title_mappings.update({
        "Ntǎ' Nùfī - Nùfī Attic - Le Grenier du Nùfī (Version sans audio)": "nufi_attic_ebook",
        "Conte Africain -Fongbe: « Travaille aujourd’hui et mange demain, paresse aujourd’hui et vole demain » – January 15, 2019" : "fongbe_conte_travaille_paresse",
        "Conte Africain -Fongbe: « Travaille aujourd’hui et mange demain, paresse aujourd’hui et vole demain »." : "fongbe_conte_travaille_paresse",

        "Guide de conversation trilingue Français-anglais-fe'efe'e.: French-Fè'éfě'è-English Phrasebook": "nufi_phrasebook",
        "La grammaire des langues bamilekes : cas du nufi": "nufi_grammaire",
        "La fourmi affamée : Nufi-Français: Nzhìèkǔ’ mɑ̀nkō ngʉ́ngà'": "nufi_fourmi_affamee",
        "Contes africains, contes bamilekés racontés en nufi et traduits en francais (Full Color): African's fairy tales": "nufi_contes_bamilekes",
        "Conversations de base en langue fe'efe'e: Basic Conversation in Fe'efe'e Language":"nufi_conv.base",
        "Conte Bamiléké-Nufi « Travaille aujourd’hui et mange demain, paresse aujourd’hui et vole demain ».: Version Nufi-Francais":"nufi_travail_paresse",
        "Contes africains, contes bamilékés racontés en nufi et traduits en français (Black and White): African's fairy tales":"nufi_contes_bamileke_black_white",
        "Contes bamilekés racontés en medumba et traduits en français (Black and White): medumba (Bangangte) Fairy tales":"medumba_contes_bamilekes_black_white",
        "Contes bamilekés racontés en medumba et traduits en français: medumba (bangante) fairy tales":"medumba_contes_bamileke_couleur",
        "Expressions idiomatiques en langue fè'éfě'è (nùfī): Yū' mfèn pí yū' nkɑ̀ndàk mɑ̀ ghə̀ə̄ fè'éfě'è (nùfī)":"nufi_expression_idiom.",
        "Grammaire des langues bamilékés : Cas du nufi (fè'éfě'è): Sìēmbʉ́ɑ́ fè'éfě'è": "nufi_grammaire",
        "Guide de conversation (phrasebook) en langue fe'efe'e (nufi) - part I: Trilingual Phrasebook : French-English-Nufi": "nufi_phrasebook",
        "Guide de conversation trilingue français-anglais-douala: French-Duala-English Phrasebook": "duala_phrasebook",
        "Guide de conversation trilingue français-anglais-medumba: French-Medumba-English Phrasebook":"medumba_phrasebook",
        "Guide de conversation trilingue français-anglais-yemba: French-Yemba-English Phrasebook":"yemba_phrasebook",
        "La fourmi affamée: Nzhìèkǔ’ mɑ̀nkō ngʉ́ngà'":"nufi_fourmi_affamee",
        "Le Grenier du Nguemba: Ntâŋ Ŋgə̂mbà : Ngemba Attic":"ngemba_grenier",
        "Syllabaire et dictionnaire visuel en langue nufi (fe’efe’e): Nkǔnjâ'wū pí mbíághəə":"nufi_syllabaire",
        "Yoruba - French - English Phrasebook: Guide de conversation Yoruba – Français - Anglais":"yoruba_phrasebook",
        "Contes africains, contes bamilekés racontés en nufi et traduits en francais: African's fairy tales, bamileke tales":"nufi_contes_bamilekes",
        "La fourmi affamée : Ŋgə̂mbà – Français: Tə́ttá pfʉ́ njjikhwu’ú":"ngemba_fourmi_affamee"
    })

    # Iterate over the dictionary items
    for key, value in title_mappings.items():
        # If the title contains the key, return the associated new nickname
        if key in title:
            return value

    # If no mapping was found, return the title itself
    return title


def count_authors(x):
    if "resulam" in x.lower():
        return len(x.split(","))
    else:
        return len(x.split(","))+1

# def replace_author(row):
#     title_lower = row['Title'].lower()
#     if 'guide de conversation trilingue français-anglais-yemba' in title_lower:
#         return 'Giresse Jiokeng Feutsa, Oliver Germain Tafouemewe, Shck Tchamna'
#     elif pd.isnull(row['Authors']) or 'nùfī' in title_lower or 'nufi' in title_lower or "fe'efe'e" in title_lower:
#         return "Resulam, Shck Tchamna"
#     else:
#         return row['Authors']

# def count_authors(authors_str):
#     if pd.isnull(authors_str):
#         return 0
#     return len([author for author in authors_str.split(",") if author.strip()])


# Apply the function and update 'Authors' column
sell_this_year_2['Authors'] = sell_this_year_2.apply(replace_author, axis=1)
sell_history_2['Authors'] = sell_history_2.apply(replace_author, axis=1)

# Apply count_authors function to count the number of authors
sell_this_year_2['Authors Count'] = sell_this_year_2['Authors'].apply(count_authors)
sell_history_2['Authors Count'] = sell_history_2['Authors'].apply(count_authors)


royalties_df = sell_this_year_2
royalties_history_df = sell_history_2

# sell_this_year_2["Authors"].unique()

ISBN_Paper = [str(i) for i in ISBN_Paper]
ISBN_HardCovers = [str(i) for i in ISBN_HardCovers]

def get_book_type_from_ISBN(x):
    if x in ISBN_Paper:
        return "Paper"
    elif x in ISBN_HardCovers:
        return "HardCover"
    elif x in ASIN_Ebook:
        return "Ebook"
    else:
        return "U"  # or return None, depending on your preference

royalties_history_df["BookType"] = royalties_history_df["ASIN/ISBN"].apply(get_book_type_from_ISBN)
royalties_history_df
royalties_history_df["BookType"].unique()





royalties_history_df[royalties_history_df["Language"]=="Fongbe"]["Title"].unique()



royalties_history_df["Language"] = royalties_history_df["Language"].apply(lang_nufi)
royalties_history_df["book_nick_name"] = royalties_history_df["book_nick_name"].apply(replace_book_nick_name)



# royalties_history_df[royalties_history_df["Title"]=="Conte Africain -Fongbe: « Travaille aujourd’hui et mange demain, paresse aujourd’hui et vole demain »."]
# royalties_history_df[royalties_history_df["book_nick_name"] == "fongbe_conte_travaille_paresse"]



# Hypothetical exchange rates
exchange_rates = {
    'EUR': 1,  # 1 Euro = 1.1 USD
    'JPY': 0.0073,  # 1 Japanese Yen = 0.0073 USD
    'USD': 1,  # 1 USD = 1 USD (for completeness)
    "CAD" : 0.8,
    'GBP': 1.3,
    "BRL": 0.2,
    "AUD": 0.7,
"PLN": 0.25,
"SEK" : 0.1
}

exchange_rates = {
    'EUR': 1,  # 1 Euro = 1.1 USD
    'JPY': 0.0073,  # 1 Japanese Yen = 0.0073 USD
    'USD': 1,  # 1 USD = 1 USD
    "CAD": 0.8,  # 1 Canadian Dollar = 0.8 USD
    'GBP': 1.3,  # 1 British Pound = 1.3 USD
    "BRL": 0.2,  # 1 Brazilian Real = 0.2 USD
    "AUD": 0.7,  # 1 Australian Dollar = 0.7 USD
    "PLN": 0.25, # 1 Polish Zloty = 0.25 USD
    "SEK": 0.1,  # 1 Swedish Krona = 0.1 USD
    "INR": 0.0126 # 1 Indian Rupee = 0.0126  USD
}

# Function to convert currency to USD
def convert_to_usd(row):
    return row['Royalty'] * exchange_rates[row['Currency']]

# Convert Royalties to USD
royalties_df['Royalty USD'] = royalties_df.apply(convert_to_usd, axis=1)
# Calculate Royalty per Author
royalties_df['Royalty per Author (USD)'] = royalties_df['Royalty USD'] / royalties_df['Authors Count']
# Display the first few rows with the new columns
royalties_df[['Title', 'Authors', 'Currency', 'Royalty', 'Royalty USD', 'Authors Count', 'Royalty per Author (USD)']].head()

####################################

# Convert Royalties to USD
royalties_history_df['Royalty USD'] = royalties_history_df.apply(convert_to_usd, axis=1)
# Calculate Royalty per Author
royalties_history_df['Royalty per Author (USD)'] = royalties_history_df['Royalty USD'] / royalties_history_df['Authors Count']
# Display the first few rows with the new columns
royalties_history_df[['Title', "Language", 'Authors', 'Currency', 'Royalty', 'Royalty USD', 'Authors Count', 'Royalty per Author (USD)']].head()

"""# Save Processed Data"""

royalties_history_df.to_csv("royalties_resulambooks_from_2015_history_df.csv",encoding="utf 8-sig")

"""# Data Analysis"""



"""## Number of book sold per year"""



import pandas as pd
import plotly.express as px
from datetime import datetime

# Extract year from the 'Royalty Date' column
royalties_history_df['Year Sold'] = pd.to_datetime(royalties_history_df['Royalty Date']).dt.year

# Get the current year
current_year = datetime.now().year

# Exclude the current year from the analysis
royalties_history_df = royalties_history_df[royalties_history_df['Year Sold'] != current_year]

# Group by year and sum the 'Net Units Sold'
units_sold_by_year = royalties_history_df.groupby('Year Sold')['Net Units Sold'].sum().reset_index()

# Sort the DataFrame from biggest to smallest 'Net Units Sold'
units_sold_by_year = units_sold_by_year.sort_values(by='Net Units Sold', ascending=False)

# Create the plot with a white background
fig = px.bar(units_sold_by_year, x='Year Sold', y='Net Units Sold',
             title=f'Number of Books Sold sold by Resulam per Year, from 2015 to {current_year - 1}',
             labels={'Year Sold': 'Year Sold', 'Net Units Sold': 'Net Units Sold'}, text='Net Units Sold',
             template='plotly_white')

# Show the plot
fig.show()

# pip show nbformat





# import pandas as pd
# import plotly.express as px
# from datetime import datetime

# # Extract year from the 'Royalty Date' column
# royalties_history_df['Year Sold'] = pd.to_datetime(royalties_history_df['Royalty Date']).dt.year

# # Exclude the current year
# current_year = datetime.now().year
# royalties_history_df = royalties_history_df[royalties_history_df['Year Sold'] != current_year]

# # Group by year and language, and sum the 'Net Units Sold'
# units_sold_by_year_language = royalties_history_df.groupby(['Year Sold', 'Language'])['Net Units Sold'].sum().reset_index()

# # Create an interactive plot with discrete years on the x-axis
# fig = px.bar(units_sold_by_year_language, x='Year Sold', y='Net Units Sold', color='Language',
#              title=f'Number of Books Sold from 2015 to {current_year - 1} by Language',
#              labels={'Year Sold': 'Year Sold', 'Net Units Sold': 'Net Units Sold'},
#              template='plotly_white',
#              category_orders={"Year Sold": sorted(units_sold_by_year_language['Year Sold'].unique())})

# # Get unique languages
# unique_languages = units_sold_by_year_language['Language'].unique()

# # Create a boolean array for the visibility of each language
# traces = []
# for lang in unique_languages:
#     visible = units_sold_by_year_language['Language'] == lang
#     traces.extend([True if v else False for v in visible])

# # Update layout for dropdown
# language_buttons = []
# for i, lang in enumerate(unique_languages):
#     visibility = [False] * len(unique_languages) * len(units_sold_by_year_language['Year Sold'].unique())
#     visibility[i::len(unique_languages)] = [True] * len(units_sold_by_year_language['Year Sold'].unique())
#     language_buttons.append(dict(label=lang, method="update", args=[{"visible": visibility}]))

# # Add an 'All' button
# all_button = dict(args=[{"visible": [True] * len(traces)}], label="All", method="update")

# fig.update_layout(
#     updatemenus=[
#         dict(
#             buttons=[all_button] + language_buttons,
#             direction="down",
#             showactive=True,
#         )
#     ]
# )

# # Show the plot
# fig.show()



import pandas as pd
import plotly.graph_objects as go
from datetime import datetime

# Extract year from the 'Royalty Date' column
royalties_history_df['Year Sold'] = pd.to_datetime(royalties_history_df['Royalty Date']).dt.year

# Exclude the current year
current_year = datetime.now().year
royalties_history_df = royalties_history_df[royalties_history_df['Year Sold'] != current_year]

# Group by year and language, and sum the 'Net Units Sold'
units_sold_by_year_language = royalties_history_df.groupby(['Year Sold', 'Language'])['Net Units Sold'].sum().reset_index()


# Assuming royalties_history_df is defined and contains 'Royalty Date', 'Language', and 'Net Units Sold' columns
units_sold_by_yearld_by_year_language = royalties_history_df.groupby(['Year Sold', 'Language'])['Net Units Sold'].sum().reset_index()

# Extract year from the 'Royalty Date' column and exclude the current year
royalties_history_df['Year Sold'] = pd.to_datetime(royalties_history_df['Royalty Date']).dt.year
current_year = datetime.now().year
royalties_history_df = royalties_history_df[royalties_history_df['Year Sold'] != current_year]

# Group by year and language, and sum the 'Net Units Sold'

excluded_languages = ['Bamileke', 'Africa']
units_sold_by_year_language = units_sold_by_year_language[~units_sold_by_year_language['Language'].isin(excluded_languages)]

# Sort languages alphabetically after excluding
sorted_languages = sorted(units_sold_by_year_language['Language'].unique())

# Create a Plotly figure with stacked bars initially
fig = go.Figure()

# Add a bar trace for each language
for language in sorted_languages:
    filtered_df = units_sold_by_year_language[units_sold_by_year_language['Language'] == language]
    fig.add_trace(go.Bar(
        x=filtered_df['Year Sold'],
        y=filtered_df['Net Units Sold'],
        name=language
    ))

# Create dropdown buttons
dropdown_buttons = [
    {'label': 'All (Stacked)', 'method': 'update',
     'args': [{'visible': [True] * len(sorted_languages)}, {'barmode': 'stack'},
              {'title': 'Resulam Number of Books Sold by Language per Year', 'text': [None] * len(sorted_languages)}]},
]

for i, language in enumerate(sorted_languages):
    visibility = [False] * len(sorted_languages)
    visibility[i] = True
    text_labels = [None] * len(sorted_languages)
    text_labels[i] = units_sold_by_year_language[units_sold_by_year_language['Language'] == language]['Net Units Sold']
    dropdown_buttons.append(
        {'label': language, 'method': 'update',
         'args': [{'visible': visibility}, {'barmode': 'group'}, {'title': f'Books Sold in {language}', 'text': text_labels}]}
    )

# Update layout for dropdown and initial stacked mode
fig.update_layout(
    plot_bgcolor='rgba(255,255,255,1)',
    paper_bgcolor='rgba(255,255,255,1)',
    updatemenus=[
        dict(
            buttons=dropdown_buttons,
            direction='down',
            showactive=True,
            x=0.9,
            xanchor='right',
            y=1.15,
            yanchor='top'
        )
    ],
    title='Number of Books Sold by Language',
    xaxis_title='Year Sold',
    yaxis_title='Net Units Sold',
    barmode='stack'
)

# Add text to bars for specific language view
for i, trace in enumerate(fig.data):
    trace.text = units_sold_by_year_language[units_sold_by_year_language['Language'] == sorted_languages[i]]['Net Units Sold']
    trace.textposition = 'inside'

# Show the plot
fig.show()



import pandas as pd
import plotly.graph_objects as go
from datetime import datetime

def barplot(royalties_history_df,field_of_interest = 'Language'):

    # Extract year from the 'Royalty Date' column
    royalties_history_df['Year Sold'] = pd.to_datetime(royalties_history_df['Royalty Date']).dt.year

    # Exclude the current year
    current_year = datetime.now().year
    royalties_history_df = royalties_history_df[royalties_history_df['Year Sold'] != current_year]

    # Group by year and language, and sum the 'Net Units Sold'
    units_sold_by_year_language = royalties_history_df.groupby(['Year Sold', field_of_interest])['Net Units Sold'].sum().reset_index()


    # Assuming royalties_history_df is defined and contains 'Royalty Date', 'Language', and 'Net Units Sold' columns
    units_sold_by_yearld_by_year_language = royalties_history_df.groupby(['Year Sold', field_of_interest])['Net Units Sold'].sum().reset_index()

    # Extract year from the 'Royalty Date' column and exclude the current year
    royalties_history_df['Year Sold'] = pd.to_datetime(royalties_history_df['Royalty Date']).dt.year
    current_year = datetime.now().year
    royalties_history_df = royalties_history_df[royalties_history_df['Year Sold'] != current_year]

    # Group by year and language, and sum the 'Net Units Sold'

    excluded_languages = ['Bamileke', 'Africa']
    units_sold_by_year_language = units_sold_by_year_language[~units_sold_by_year_language[field_of_interest].isin(excluded_languages)]

    # Sort languages alphabetically after excluding
    sorted_languages = sorted(units_sold_by_year_language[field_of_interest].unique())

    # Create a Plotly figure with stacked bars initially
    fig = go.Figure()

    # Add a bar trace for each language
    for language in sorted_languages:
        filtered_df = units_sold_by_year_language[units_sold_by_year_language[field_of_interest] == language]
        fig.add_trace(go.Bar(
            x=filtered_df['Year Sold'],
            y=filtered_df['Net Units Sold'],
            name=language
        ))

    # Create dropdown buttons
    dropdown_buttons = [
        {'label': 'All (Stacked)', 'method': 'update',
         'args': [{'visible': [True] * len(sorted_languages)}, {'barmode': 'stack'},
                  {'title': f'Resulam Number of Books Sold by Language per Year', 'text': [None] * len(sorted_languages)}]},
    ]

    for i, language in enumerate(sorted_languages):
        visibility = [False] * len(sorted_languages)
        visibility[i] = True
        text_labels = [None] * len(sorted_languages)
        text_labels[i] = units_sold_by_year_language[units_sold_by_year_language[field_of_interest] == language]['Net Units Sold']
        dropdown_buttons.append(
            {'label': language, 'method': 'update',
             'args': [{'visible': visibility}, {'barmode': 'group'}, {'title': f'Books Sold in {language}', 'text': text_labels}]}
        )

    # Update layout for dropdown and initial stacked mode
    fig.update_layout(
        plot_bgcolor='rgba(255,255,255,1)',
        paper_bgcolor='rgba(255,255,255,1)',
        updatemenus=[
            dict(
                buttons=dropdown_buttons,
                direction='down',
                showactive=True,
                x=0.9,
                xanchor='right',
                y=1.15,
                yanchor='top'
            )
        ],
        title=f'Number of Books Sold per {field_of_interest}',
        xaxis_title='Year Sold',
        yaxis_title='Net Units Sold',
        barmode='stack'
    )

    # Add text to bars for specific language view
    for i, trace in enumerate(fig.data):
        trace.text = units_sold_by_year_language[units_sold_by_year_language[field_of_interest] == sorted_languages[i]]['Net Units Sold']
        trace.textposition = 'inside'

    # Show the plot
    fig.show()

barplot(royalties_history_df,field_of_interest = 'book_nick_name')



"""## Type of book sold"""





import pandas as pd
import plotly.graph_objects as go

def plot_books_sold_by_title_horizontal(royalties_df):
    # Group by title and sum the net units sold
    units_sold_by_title = royalties_df.groupby('book_nick_name')['Net Units Sold'].sum().reset_index()

    # Sort the DataFrame by net units sold in descending order for better visibility
    units_sold_by_title = units_sold_by_title.sort_values(by='Net Units Sold', ascending=True)

    # Create a Plotly figure
    fig = go.Figure()

    # Add a horizontal bar trace
    fig.add_trace(go.Bar(
        y=units_sold_by_title['book_nick_name'],
        x=units_sold_by_title['Net Units Sold'],
        orientation='h'  # This creates a horizontal bar plot
    ))

    # Update layout
    fig.update_layout(
        title='Number of Books Sold by Title',
        yaxis_title='book_nick_name',
        xaxis_title='Net Units Sold'
    )

    # Show the plot
    fig.show()

# Call the function with the DataFrame
plot_books_sold_by_title_horizontal(royalties_history_df)





import pandas as pd
import plotly.graph_objects as go

def plot_books_sold_by_title_horizontal(royalties_df):
    # Extract year from 'Royalty Date' and add as a new column
    royalties_df['Year Sold'] = pd.to_datetime(royalties_df['Royalty Date']).dt.year

    # Sort years for the dropdown
    sorted_years = sorted(royalties_df['Year Sold'].unique())

    # Create the figure object
    fig = go.Figure()

    for year in sorted_years:
        # Filter the DataFrame for the selected year
        df_filtered = royalties_df[royalties_df['Year Sold'] == year]

        # Group by title and sum the net units sold for the filtered DataFrame
        units_sold_by_title = df_filtered.groupby('book_nick_name')['Net Units Sold'].sum().reset_index()

        # Sort by net units sold in ascending order
        units_sold_by_title = units_sold_by_title.sort_values(by='Net Units Sold', ascending=True)

        # Add a bar trace for each year
        fig.add_trace(go.Bar(
            y=units_sold_by_title['book_nick_name'],
            x=units_sold_by_title['Net Units Sold'],
            orientation='h',
            name=str(year)  # Use the year as the name for the trace
        ))

    # Create dropdown buttons for year filtering
    dropdown_buttons = [
        {'label': str(year), 'method': 'update',
         'args': [{'visible': [year == y for y in sorted_years]},
                  {'title': f'Number of Books Sold by Title in {year}'}]}
        for year in sorted_years
    ]

    # Add 'Show All' option to the dropdown
    dropdown_buttons.append(
        {'label': 'Show All', 'method': 'update',
         'args': [{'visible': [True] * len(sorted_years)},  # Set all traces to visible
                  {'title': 'Number of Books Sold by Title'}]}
    )

    # Update layout to include dropdown
    fig.update_layout(
        updatemenus=[{
            'buttons': dropdown_buttons,
            'direction': 'down',
            'x': 0.5,
            'xanchor': 'center',
            'y': 1.2,
            'yanchor': 'top'
        }],
        title='Number of Books Sold by Title',
        yaxis_title='book_nick_name',
        xaxis_title='Net Units Sold',
        showlegend=False  # Hide the legend if not necessary
    )

    # Show the plot
    fig.show()

# Call the function with the DataFrame
plot_books_sold_by_title_horizontal(royalties_history_df)





import dash
from dash import html, dcc, Input, Output
import plotly.graph_objects as go
import pandas as pd

# Assuming royalties_history_df is your DataFrame

app = dash.Dash(__name__)

app.layout = html.Div([
    dcc.Input(id='book-name-input', type='text', placeholder='Enter a book name'),
    dcc.Graph(id='books-sold-plot')
])

@app.callback(
    Output('books-sold-plot', 'figure'),
    [Input('book-name-input', 'value')]
)
def update_graph(book_name):
    try:
        fig = go.Figure()

        # Iterate through each year and create a trace
        for year in sorted(royalties_history_df['Year Sold'].unique()):
            # Filter DataFrame based on the book name input and year
            if book_name:
                filtered_df = royalties_history_df[
                    (royalties_history_df['book_nick_name'].str.contains(book_name, case=False, na=False)) &
                    (royalties_history_df['Year Sold'] == year)
                ]
            else:
                # If no book name is entered, display data for the year
                filtered_df = royalties_history_df[royalties_history_df['Year Sold'] == year]

            # Add a trace for the filtered data
            fig.add_trace(go.Bar(
                x=filtered_df['book_nick_name'],
                y=filtered_df['Net Units Sold'],
                name=str(year)  # Use year as the trace name
            ))

        # Update plot layout
        fig.update_layout(
            title='Number of Books Sold by Title',
            xaxis_title='Title',
            yaxis_title='Net Units Sold',
            legend_title="Year"
        )

        return fig
    except Exception as e:
        print(f"An error occurred: {e}")
        # Return an empty figure or error message in case of an exception
        return go.Figure()

if __name__ == '__main__':
    app.run_server(debug=True)



import dash
from dash import html, dcc, Input, Output
import plotly.graph_objects as go
import pandas as pd

# Assuming royalties_history_df is your DataFrame

app = dash.Dash(__name__)

app.layout = html.Div([
    dcc.Input(id='book-name-input', type='text', placeholder='Enter a book name'),
    dcc.Graph(id='books-sold-plot')
])

@app.callback(
    Output('books-sold-plot', 'figure'),
    [Input('book-name-input', 'value')]
)
def update_graph(book_name):
    try:
        # Filter DataFrame based on the book name input
        if book_name:
            filtered_df = royalties_history_df[royalties_history_df['book_nick_name'].str.contains(book_name, case=False, na=False)]
        else:
            # If no book name is entered, display the full dataset
            filtered_df = royalties_history_df

        # Plotting code using filtered_df
        fig = go.Figure(data=[
            go.Bar(
                x=filtered_df['book_nick_name'],  # Adjust column names as needed
                y=filtered_df['Net Units Sold']   # Adjust column names as needed
            )
        ])
        fig.update_layout(title='Number of Books Sold by Title', xaxis_title='Title', yaxis_title='Net Units Sold')

        return fig
    except Exception as e:
        print(f"An error occurred: {e}")
        # Return an empty figure or error message in case of an exception
        return go.Figure()

if __name__ == '__main__':
    app.run(debug=True)








"""# Total Book Sold By Resulam History"""



royalties_history_df["Net Units Sold"].sum()



TotalRevenue = royalties_history_df["Royalty USD"].sum()
TotalRevenue = round(TotalRevenue,2)
Total_shared = royalties_history_df["Royalty per Author (USD)"].sum()
Total_shared = round(Total_shared,2)

Resulam_share = TotalRevenue - Total_shared
TotalRevenue,Total_shared, Resulam_share



"""# Authors Individual Impact

**Notice on Authors' Individual Impact Analysis**
<br>Please be aware that in this section, we will be expanding the dataset to analyze each author's individual contribution. This process involves "exploding" the data, which means creating duplicate rows for entries with multiple authors. Each author will be represented separately to accurately assess their individual contributions.

Important Caution: Due to this duplication of rows, the data in this section should not be used for overall metrics or global analyses. It is specifically tailored for individual author impact assessment and might lead to misleading conclusions if used for broader metrics. Keep this in mind when interpreting the results from this section.






"""



"""## Explode Authors Field"""

royalties_df['Authors'].unique()



# Exploding the 'Authors' column to create a separate row for each author per book
# Assuming the authors are separated by a comma in the 'Authors' column

# df_exploded = royalties_df.assign(Authors=royalties_df['Authors'].str.split(',')).explode('Authors')

# Split the 'Authors' column into a list of authors
royalties_df['Authors_Exploded'] = royalties_df['Authors'].str.strip().str.split(',')
royalties_history_df['Authors_Exploded'] = royalties_history_df['Authors'].str.strip().str.split(',')

# Explode the 'Authors' list into separate rows
royalties_df_exploded = royalties_df.explode('Authors_Exploded')
royalties_df_exploded['Authors_Exploded'] = royalties_df_exploded['Authors_Exploded'].str.strip()

# Explode the 'Authors' list into separate rows
royalties_history_df_exploded = royalties_history_df.explode('Authors_Exploded')
royalties_history_df_exploded['Authors_Exploded'] = royalties_history_df_exploded['Authors_Exploded'].str.strip()
# Displaying the first few rows of the exploded dataframe
# royalties_df_exploded.to_csv("royalties_df_exploded.csv",encoding="utf 8-sig")
display(royalties_df_exploded.tail(2))

royalties_history_df_exploded.head(2)

royalties_history_df_exploded.tail(2)





# royalties_df["Net Units Sold"].sum()
# royalties_df_exploded["Authors_Exploded"] = royalties_df_exploded["Authors_Exploded"].apply(lambda x: x.strip())

# # royalties_df_exploded["Net Units Sold"].sum()
# sorted(royalties_df_exploded["Authors_Exploded"].unique())









author_names_dict = {
    "Shck Shck Tchamna":"Shck Tchamna",
    "Shck Shck Tchamna":"Shck Tchamna",
    "Shck Ca᷅mnà'":"Shck Tchamna",
    "Shck Cǎmnà'":"Shck Tchamna",

    "Claude Lionel Mvondo Edzoa": "Claude Lionel Mvondo",
    "IMELE TSAFACK": "Imele Tsafack",
    "Tsafack Imele": "Imele Tsafack",
    "Jean rene Djobia":"Jean René Djobia",
    "Tanyi Djobia Rene":"Jean René Djobia",
    "Joseph Oyange Wajuanga":"Joseph Oyange",
    "Josephine Ndonke":"Joséphine Ndonke",
    "Pascaline Motoum":"Mə̂fo Gòmlù’ Motoum",
    "Oliver Germain Tafouemewe":"Olivier Tafouemewe",
    "Zachée Denis BITJAA KODY":"Pr Zachée Denis BITJAA KODY",
    "Zachee Bitjaa Kody":"Pr Zachée Denis BITJAA KODY",
    "Iyo Ngobo Ekwalla":"Ngobo Ekwala",


}



"""## Cleaning Authors' names"""

# royalties_df_exploded["Authors_Exploded"].apply(clean_author_names)
royalties_df_exploded['Authors_Exploded'] = royalties_df_exploded['Authors_Exploded'].replace(author_names_dict)

royalties_history_df_exploded['Authors_Exploded'] = royalties_history_df_exploded['Authors_Exploded'].replace(author_names_dict)


# unique_authors = sorted(royalties_df_exploded['Authors_Exploded'].replace(author_names_dict).unique())

unique_authors = royalties_history_df_exploded['Authors_Exploded'].unique()
unique_authors_history = royalties_df_exploded['Authors_Exploded'].unique()

# sorted(list(unique_authors))

len(unique_authors_history)

# Grouping the exploded DataFrame by 'Authors_Exploded' and calculating the sum
# Then resetting the index and selecting specific columns
grouped_df = royalties_df_exploded.groupby("Authors_Exploded").sum().reset_index()
royalties_df_ = grouped_df[["Authors_Exploded", "Units Sold", "Royalty USD", "Royalty per Author (USD)"]]


royalties_df_ = royalties_df_.sort_values(by="Royalty per Author (USD)").reset_index(drop=True)
royalties_df_

# Grouping the exploded DataFrame by 'Authors_Exploded' and calculating the sum
# Then resetting the index and selecting specific columns
grouped_df_history = royalties_history_df_exploded.groupby("Authors_Exploded").sum().reset_index()
royalties_df_history = grouped_df_history[["Authors_Exploded", "Units Sold", "Royalty USD", "Royalty per Author (USD)"]]


royalties_df_history = royalties_df_history.sort_values(by="Royalty per Author (USD)").reset_index(drop=True)
royalties_df_history

grouped_df_history_count = royalties_history_df_exploded.groupby("Authors_Exploded").count().reset_index()
grouped_df_history_count = grouped_df_history_count[["Authors_Exploded","Units Sold"]].sort_values(by = "Units Sold")
grouped_df_history_count









"""# Adjusted Royalties"""







adjusted_amount = 5 # IN USD

def adjust_royalties(x):
    if x< 100:
        return round(x+adjusted_amount,2)
    else:
        return round(x,2)

royalties_per_author_final = royalties_df_[["Authors_Exploded","Units Sold","Royalty per Author (USD)"]].copy()

royalties_per_author_final["Royalty per Author (USD)"] = \
royalties_per_author_final["Royalty per Author (USD)"].apply(adjust_royalties)

royalties_per_author_final = royalties_per_author_final.rename(columns={"Authors_Exploded":"Authors"})

# royalties_per_author_final_to_share.index = range(1, len(royalties_per_author_final_to_share) + 1)

display(royalties_per_author_final)
msk = royalties_per_author_final["Authors"] != "Shck Tchamna"
royalties_per_author_final_to_share = royalties_per_author_final[msk]
royalties_per_author_final_to_share

royalties_per_author_final_to_share.index = range(1, len(royalties_per_author_final_to_share) + 1)

conversion_rate = 500 # your conversion rate to XAF
royalties_per_author_final_to_share['Royalty per Author (FCFA)'] = royalties_per_author_final_to_share['Royalty per Author (USD)'] * conversion_rate
royalties_per_author_final_to_share







royalties_per_author_final_to_share



royalties_per_author_final_to_share.to_csv(f"royalties_per_author_final_to_share_{last_year}.csv",encoding="utf 8-sig")



sell_history["Marketplace"].unique()
sell_history["Year"] = sell_history["Royalty Date"].apply(lambda x: x.split("-")[0])
sell_history["Month"] = sell_history["Royalty Date"].apply(lambda x: x.split("-")[1])
sell_history.groupby("Marketplace")[["Units Sold","Units Refunded","Net Units Sold"]].sum()
grouped_df = sell_history.groupby(["Marketplace"])[["Units Sold","Units Refunded","Net Units Sold"]].count()
# grouped_df.to_csv("MarketPlaceResulamBooks.csv")
# mask = sell_2023["Authors"].apply(lambda x: True if x is None else False)
grouped_df_ = grouped_df.reset_index()
grouped_df_

# pip install cartopy



df.to_csv("MarketPlaceResulamBooks_updated.csv",encoding="utf 8-sig")



df = grouped_df.reset_index()

# Standardize country names for mapping
# Updated country mapping for all marketplaces
country_mapping = {
    "Amazon.ca": "Canada",
    "Amazon.co.jp": "Japan",
    "Amazon.co.uk": "United Kingdom",
    "Amazon.com": "United States",
    "Amazon.com.au": "Australia",
    "Amazon.com.br": "Brazil",
    "Amazon.de": "Germany",
    "Amazon.es": "Spain",
    "Amazon.fr": "France",
    "Amazon.in": "India",
    "Amazon.it": "Italy",
    "Amazon.nl": "Netherlands",
    "Amazon.pl": "Poland",
    "Amazon.se": "Sweden",
    "CreateSpace DE": "Germany",
    "CreateSpace UK": "United Kingdom",
    "CreateSpace US": "United States"
}

# Mapping is now complete and can be used in data processing. 🚀

# Replace marketplace names with country names
df["Country"] = df["Marketplace"].map(country_mapping)

# Aggregate sales by country
sales_data = df.groupby("Country")["Net Units Sold"].sum().reset_index()

# Define a function to get latitude and longitude for a country
geolocator = Nominatim(user_agent="geoapiExercises")

def get_coordinates(country):
    try:
        location = geolocator.geocode(country)
        if location:
            return location.latitude, location.longitude
    except:
        return None, None
    return None, None

# Get coordinates for each country
sales_data["Latitude"], sales_data["Longitude"] = zip(*sales_data["Country"].apply(get_coordinates))

# Drop rows with missing coordinates
sales_data = sales_data.dropna(subset=["Latitude", "Longitude"])

# Create a world map using Cartopy
fig, ax = plt.subplots(figsize=(12, 8), subplot_kw={'projection': ccrs.PlateCarree()})

# Add map features
ax.add_feature(cfeature.LAND, color="lightgray")
ax.add_feature(cfeature.BORDERS, linestyle=":")

# Plot sales locations with circle sizes based on book sales
ax.scatter(sales_data["Longitude"], sales_data["Latitude"],
           s=sales_data["Net Units Sold"] * 10, color="red", alpha=0.6, edgecolors="black")

# Annotate country names
for idx, row in sales_data.iterrows():
    ax.text(row["Longitude"], row["Latitude"], row["Country"], fontsize=10, ha="right", transform=ccrs.PlateCarree())

# Labels and title
ax.set_title("Book Sales by Country", fontsize=14)
plt.show()

